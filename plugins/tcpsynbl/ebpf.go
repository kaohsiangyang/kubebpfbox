package tcpsynbl

//go:generate go run github.com/cilium/ebpf/cmd/bpf2go -type event -target amd64 tcpsynbl ../../ebpf/tcpsynbl/tcpsynbl.c

import (
	"bytes"
	"encoding/binary"
	"errors"
	"fmt"
	"io/ioutil"
	"kubebpfbox/global"
	"kubebpfbox/internal/pid2pod"
	"os"

	"github.com/cilium/ebpf"
	"github.com/cilium/ebpf/link"
	"github.com/cilium/ebpf/ringbuf"
	"github.com/cilium/ebpf/rlimit"
)

type TcpsynblEbpf struct {
	stopper chan struct{}
	objs    tcpsynblObjects
	kpv4    link.Link
	kpv6    link.Link
	ch      chan Event
}

func NewTcpsynblEbpf(ch chan Event) *TcpsynblEbpf {
	return &TcpsynblEbpf{
		stopper: make(chan struct{}),
		ch:      ch,
	}
}

// Load loads the tcpsynbl eBPF program into the kernel.
func (t *TcpsynblEbpf) Load() (err error) {
	// Remove the memlock limit.
	if err = rlimit.RemoveMemlock(); err != nil {
		global.Logger.Fatalf("Removing memlock: %v", err)
		return errors.New("removing memlock")
	}

	// Load the tcpsynbl eBPF program into the kernel.
	t.objs = tcpsynblObjects{}
	if err = loadTcpsynblObjects(&t.objs, nil); err != nil {
		global.Logger.Fatalf("Loading objects failed: %v", err)
		var verr *ebpf.VerifierError
		if errors.As(err, &verr) {
			global.Logger.Fatalf("%+v\n", verr)
		}
		return errors.New("loading objects failed")
	}

	// Attach the tcpsynbl eBPF program to the kernel.
	if t.kpv4, err = link.Kprobe("tcp_v4_syn_recv_sock", t.objs.DoEntry, nil); err != nil {
		global.Logger.Fatalf("Attaching kprobe failed: %v", err)
		return errors.New("attaching kprobe failed")
	}
	if t.kpv6, err = link.Kprobe("tcp_v6_syn_recv_sock", t.objs.DoEntryV6, nil); err != nil {
		global.Logger.Fatalf("Attaching kprobe failed: %v", err)
		return errors.New("attaching kprobe failed")
	}
	return nil
}

// Start starts the tcpsynbl eBPF program.
func (t *TcpsynblEbpf) Start() error {
	// Create a ring buffer reader for the packets map.
	rd, err := ringbuf.NewReader(t.objs.Events)
	if err != nil {
		global.Logger.Fatalf("opening ringbuf reader error: %s", err)
		return errors.New("opening ringbuf reader error:" + err.Error())
	}
	defer rd.Close()

	// Close the reader when unload, which will exit the read loop.
	go func() {
		<-t.stopper
		t.Unload()
		if err := rd.Close(); err != nil {
			global.Logger.Errorf("closing ringbuf reader: %s", err)
		}
	}()

	// tcpsynblEvent is generated by bpf2go.
	var event tcpsynblEvent
	for {
		record, err := rd.Read()
		if err != nil {
			if errors.Is(err, ringbuf.ErrClosed) {
				t.stopper <- struct{}{}
				global.Logger.Info("Exiting..")
				return errors.New("exiting")
			}
			global.Logger.Errorf("Reading from reader failed: %s", err)
			continue
		}

		// Parse the ringbuf event entry into a tcpsynblEvent structure.
		if err := binary.Read(bytes.NewBuffer(record.RawSample), binary.LittleEndian, &event); err != nil {
			global.Logger.Errorf("Parsing ringbuf event failed: %s", err)
			continue
		}

		// Decode tcpsynblEvent to tcpsynbl metric
		if tcpsynbl, err := DecodeMapItem(&event); err != nil {
			global.Logger.Errorf("Decode map item error: %v", err)
		} else {
			global.Logger.Infof("Get tcpsynbl metric: %s", tcpsynbl.String())
			t.ch <- *tcpsynbl
		}
	}
}

// Unload unloads the tcpsynbl eBPF program from the kernel.
func (t *TcpsynblEbpf) Unload() error {
	if err := t.kpv4.Close(); err != nil {
		global.Logger.Errorf("Detach BPF program failed: %v", err)
		return errors.New("detach BPF program failed")
	}
	if err := t.kpv6.Close(); err != nil {
		global.Logger.Errorf("Detach BPF program failed: %v", err)
		return errors.New("detach BPF program failed")
	}
	if err := t.objs.Close(); err != nil {
		global.Logger.Errorf("Closing objects failed: %v", err)
		return errors.New("closing objects failed")
	}
	return nil
}

// DecodeMapItem decode tcpsynblEvent form ringbuf to tcpsynbl metric
func DecodeMapItem(event *tcpsynblEvent) (*Event, error) {
	e := new(Event)
	e.Pid = event.Pid
	e.Comm = getCommByPid(event.Pid)
	e.MaxAckBacklog = event.MaxAckBacklog
	e.AckBacklog = event.AckBacklog

	if podInfo, err := pid2pod.GetPid2Pod().GetPodInfoByPid(e.Pid); err != nil {
		global.Logger.Errorf("Get pod info error: %v", err)
	} else {
		e.Namespace = podInfo.Namespace
		e.NodeName = podInfo.NodeName
		e.PodName = podInfo.PodName
		e.PodUID = podInfo.PodUID
		e.ContainerID = podInfo.ContainerID
		e.ContainerName = podInfo.ContainerName
	}
	return e, nil
}

// getCommByPid get process name by pid
func getCommByPid(pid uint32) string {
	f, err := os.Open(fmt.Sprintf("/proc/%d/comm", pid))
	if err != nil {
		return ""
	}
	defer f.Close()

	comm, err := ioutil.ReadAll(f)
	if err != nil {
		return ""
	}
	return string(comm)
}
