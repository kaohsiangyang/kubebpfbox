package http

//go:generate go run github.com/cilium/ebpf/cmd/bpf2go -type packet -target amd64 http ../../ebpf/http/http.c
import (
	"bytes"
	"encoding/binary"
	"errors"
	"fmt"
	"kubebpfbox/global"
	"kubebpfbox/internal/endpoint2pod"
	"net"
	"strings"
	"syscall"
	"unsafe"

	"github.com/cilium/ebpf"
	"github.com/cilium/ebpf/ringbuf"
	"github.com/cilium/ebpf/rlimit"
)

const (
	SO_ATTACH_BPF = 0x32                     // 50
	SO_DETACH_BPF = syscall.SO_DETACH_FILTER // 27
)

type HttpEbpf struct {
	stopper chan struct{}
	rawSock int
	objs    httpObjects
	ch      chan Traffic
}

func NewHttpEbpf(ch chan Traffic) *HttpEbpf {
	return &HttpEbpf{
		stopper: make(chan struct{}),
		ch:      ch,
	}
}

var (
	netIfName string
)

// Load loads the http eBPF program into the kernel.
func (h *HttpEbpf) Load() (err error) {
	netIfName = global.ClusterSetting.NetInterface

	// Remove the memlock limit.
	if err = rlimit.RemoveMemlock(); err != nil {
		global.Logger.Errorf("Removing memlock: %v", err)
		return errors.New("removing memlock")
	}

	// Load the http eBPF program into the kernel.
	h.objs = httpObjects{}
	if err = loadHttpObjects(&h.objs, nil); err != nil {
		global.Logger.Errorf("Loading objects failed: %v", err)
		var verr *ebpf.VerifierError
		if errors.As(err, &verr) {
			global.Logger.Errorf("%+v\n", verr)
		}
		return errors.New("loading objects failed")
	}

	// Open a raw socket and bind it to the specified network interface.
	if h.rawSock, err = OpenRawSock(netIfName); err != nil {
		global.Logger.Errorf("Open raw sock failed: %v", err)
		return errors.New("open raw sock failed")
	}

	// Attach the socket filter to the raw socket.
	if err = syscall.SetsockoptInt(h.rawSock, syscall.SOL_SOCKET, SO_ATTACH_BPF, h.objs.SocketFilterHttp.FD()); err != nil {
		global.Logger.Errorf("Attach BPF program failed: %v", err)
		return errors.New("attach BPF program failed")
	}
	return nil
}

// Start starts the http eBPF program.
func (h *HttpEbpf) Start() error {
	// Write host IP to the filter_ip map.
	if err := h.WriteFilterIP(); err != nil {
		return err
	}

	// Update the filter_ip map when endpoints change.
	h.Registry()

	// Create a ring buffer reader for the packets map.
	rd, err := ringbuf.NewReader(h.objs.Packets)
	if err != nil {
		global.Logger.Errorf("opening ringbuf reader: %s", err)
		return errors.New("opening ringbuf reader")
	}
	defer rd.Close()

	// Close the reader when unload, which will exit the read loop.
	go func() {
		<-h.stopper
		h.Unload()
		if err := rd.Close(); err != nil {
			global.Logger.Errorf("closing ringbuf reader: %s", err)
		}
	}()

	// httpPacket is generated by bpf2go.
	var packet httpPacket
	for {
		record, err := rd.Read()
		if err != nil {
			if errors.Is(err, ringbuf.ErrClosed) {
				h.stopper <- struct{}{}
				global.Logger.Info("Exiting..")
				return errors.New("exiting")
			}
			global.Logger.Warnf("Reading from reader failed: %s", err)
			continue
		}

		// Parse the ringbuf event entry into a httpPacket structure.
		if err := binary.Read(bytes.NewBuffer(record.RawSample), binary.LittleEndian, &packet); err != nil {
			global.Logger.Warnf("Parsing ringbuf event failed: %s", err)
			continue
		}

		// Decode httpPacket to traffic metric
		if traffic, err := DecodeMapItem(&packet); err != nil {
			global.Logger.Warnf("Decode map item error: %v", err)
		} else {
			global.Logger.Infof("Get traffic metric: %s", traffic.String())
			h.ch <- *traffic
		}
	}
}

// Unload unloads the http eBPF program from the kernel.
func (h *HttpEbpf) Unload() error {
	if err := syscall.SetsockoptInt(h.rawSock, syscall.SOL_SOCKET, SO_DETACH_BPF, h.objs.SocketFilterHttp.FD()); err != nil {
		global.Logger.Errorf("Detach BPF program failed: %v", err)
		return errors.New("detach BPF program failed")
	}
	if err := h.objs.Close(); err != nil {
		global.Logger.Errorf("Closing objects failed: %v", err)
		return errors.New("closing objects failed")
	}
	return nil
}

// AddFilterIP adds host IP to the filter_ip map.
func (h *HttpEbpf) AddFilterIP(endpoint *endpoint2pod.Endpoint, provider *endpoint2pod.Provider) error {
	if err := h.objs.FilterIp.Put(ipv4ToUint32(net.ParseIP(endpoint.IP)), uint32(1)); err != nil {
		global.Logger.Errorf("Add filter ip map failed: %v", err)
		return errors.New("add filter ip map failed")
	}
	global.Logger.Debugf("Add filter ip map successfully, ip: %s", endpoint.IP)
	return nil
}

// DeleteFilterIP deletes host IP from the filter_ip map.
func (h *HttpEbpf) DeleteFilterIP(endpoint *endpoint2pod.Endpoint, provider *endpoint2pod.Provider) error {
	if err := h.objs.FilterIp.Delete(ipv4ToUint32(net.ParseIP(endpoint.IP))); err != nil {
		global.Logger.Errorf("Delete filter ip map failed: %v", err)
		return errors.New("delete filter ip map failed")
	}
	global.Logger.Debugf("Delete filter ip map successfully, ip: %s", endpoint.IP)
	return nil
}

// Registry registers HttpEbpf to endpoint2pod controller
func (h *HttpEbpf) Registry() {
	endpoint2pod := endpoint2pod.GetEndpoint2Pod()
	endpoint2pod.AddEventHandlers = append(endpoint2pod.AddEventHandlers, h.AddFilterIP)
	endpoint2pod.DeleteEventHandlers = append(endpoint2pod.DeleteEventHandlers, h.DeleteFilterIP)
}

// WriteFilterIP writes host IP to the filter_ip map.
func (h *HttpEbpf) WriteFilterIP() error {
	// TODO: 向Endpoints2Pods中注册回调函数，当Endpoints发生变化时，更新filter_ip map, 然后测试
	for provider := range endpoint2pod.GetEndpoint2Pod().Providers {
		if err := h.objs.FilterIp.Put(ipv4ToUint32(net.ParseIP(provider.IP)), uint32(1)); err != nil {
			global.Logger.Errorf("Write filter ip map failed: %v", err)
			return errors.New("write filter ip map failed")
		}
		global.Logger.Debugf("Write filter ip map successfully, ip: %s", provider.IP)
	}
	return nil
}

// OpenRawSock opens a raw socket and binds it to the specified network interface.
func OpenRawSock(netIfName string) (int, error) {
	// ETH_P_IP: Internet Protocol version 4 (IPv4)
	// ETH_P_ARP: Address Resolution Protocol (ARP)
	// ETH_P_IPV6: Internet Protocol version 6 (IPv6)
	// ETH_P_RARP: Reverse ARP
	// ETH_P_LOOP: Loopback protocol
	const ETH_P_ALL uint16 = 0x03

	// Create a raw socket that listens to all protocols.
	sock, err := syscall.Socket(syscall.AF_PACKET,
		syscall.SOCK_RAW|syscall.SOCK_NONBLOCK|syscall.SOCK_CLOEXEC, int(Htons(ETH_P_ALL)))
	if err != nil {
		return 0, err
	}

	sll := syscall.SockaddrLinklayer{}
	sll.Protocol = Htons(ETH_P_ALL)

	netIf, err := net.InterfaceByName(netIfName)
	if err != nil {
		return 0, err
	}
	sll.Ifindex = netIf.Index

	// Bind the socket to the specified network interface.
	if err := syscall.Bind(sock, &sll); err != nil {
		return 0, err
	}
	return sock, nil
}

// DecodeMapItem decode httpPacket form ringbuf to traffic metric
func DecodeMapItem(packet *httpPacket) (*Traffic, error) {
	traffic := new(Traffic)
	traffic.Type = packet.Type
	traffic.DstIP = intToIP(packet.DstIp).String()
	traffic.DstPort = Ntohs(packet.DstPort)
	traffic.SrcIP = intToIP(packet.SrcIp).String()
	traffic.SrcPort = Ntohs(packet.SrcPort)
	traffic.Duration = float32(packet.Duration) / (1000 * 1000)
	traffic.Method = MethodToString(packet.Method)
	traffic.URL = strings.TrimRight(string(packet.Url[:]), "\x00")
	traffic.Code = string(packet.Status[:])
	if provider, ok := endpoint2pod.GetEndpoint2Pod().GetPodByEndpoint(traffic.DstIP, int32(traffic.DstPort)); ok {
		traffic.Flow = 1
		traffic.PodName = provider.PodName
		traffic.NodeName = provider.NodeName
		traffic.NameSpace = provider.NameSpace
		traffic.ServiceName = provider.ServiceName
	} else {
		return nil, fmt.Errorf("can't find pod by Endpoint: [%s:%d]", traffic.DstIP, traffic.DstPort)
	}
	return traffic, nil
}

// MethodToString converts method uint32 to string
func MethodToString(method uint32) string {
	switch method {
	case 1:
		return "GET"
	case 2:
		return "POST"
	case 3:
		return "PUT"
	case 4:
		return "DELETE"
	case 5:
		return "HEAD"
	case 6:
		return "PATCH"
	}
	return ""
}

// ipv4ToUint32 converts net.IP to IPv4 number
func ipv4ToUint32(ip net.IP) uint32 {
	return uint32(ip[0])<<24 | uint32(ip[1])<<16 | uint32(ip[2])<<8 | uint32(ip[3])
}

// intToIP converts IPv4 number to net.IP
func intToIP(ipNum uint32) net.IP {
	ip := make(net.IP, 4)
	binary.LittleEndian.PutUint32(ip, ipNum)
	return ip
}

// Htons converts to network byte order short uint16.
func Htons(i uint16) uint16 {
	b := make([]byte, 2)
	binary.BigEndian.PutUint16(b, i)
	return *(*uint16)(unsafe.Pointer(&b[0]))
}

// Htonl converts to network byte order long uint32.
func Htonl(i uint32) uint32 {
	b := make([]byte, 4)
	binary.BigEndian.PutUint32(b, i)
	return *(*uint32)(unsafe.Pointer(&b[0]))
}

// Ntohs converts to host byte order short uint16.
func Ntohs(i uint16) uint16 {
	b := make([]byte, 2)
	binary.BigEndian.PutUint16(b, i)
	return *(*uint16)(unsafe.Pointer(&b[0]))
}

// Ntohs converts to host byte order short uint32.
func Ntohl(i uint32) uint32 {
	b := make([]byte, 4)
	binary.BigEndian.PutUint32(b, i)
	return *(*uint32)(unsafe.Pointer(&b[0]))
}
