package http

//go:generate go run github.com/cilium/ebpf/cmd/bpf2go -type packet --target=amd64 http ../../ebpf/http/http.c
import (
	"bytes"
	"encoding/binary"
	"errors"
	"fmt"
	"kubebpfbox/global"
	"log"
	"net"
	"syscall"
	"unsafe"

	"github.com/cilium/ebpf"
	"github.com/cilium/ebpf/ringbuf"
	"github.com/cilium/ebpf/rlimit"
)

const (
	SO_ATTACH_BPF = 0x32                     // 50
	SO_DETACH_BPF = syscall.SO_DETACH_FILTER // 27
)

type HttpEbpf struct {
	stopper chan struct{}
	rawSock int
	objs    httpObjects
	ch      chan Traffic
}

func NewHttpEbpf(ch chan Traffic) *HttpEbpf {
	return &HttpEbpf{
		ch: ch,
	}
}

const (
	netIfName = "eth0"
	hostIP    = "192.168.122.180"
)

func (h *HttpEbpf) Load() (err error) {
	// Remove the memlock limit.
	if err = rlimit.RemoveMemlock(); err != nil {
		log.Fatalf("Removing memlock: %v", err)
	}

	// Load the http eBPF program into the kernel.
	h.objs = httpObjects{}
	if err = loadHttpObjects(&h.objs, nil); err != nil {
		if err != nil {
			var verr *ebpf.VerifierError
			if errors.As(err, &verr) {
				fmt.Printf("%+v\n", verr)
			}
		}
		log.Fatalf("loading objects: %v", err)
	}
	defer h.objs.Close()

	// Open a raw socket and bind it to the specified network interface.
	if h.rawSock, err = OpenRawSock(netIfName); err != nil {
		log.Fatalf("Open raw sock failed: %v", err)
	}

	// Attach the socket filter to the raw socket.
	if err = syscall.SetsockoptInt(h.rawSock, syscall.SOL_SOCKET, SO_ATTACH_BPF, h.objs.SocketFilterHttp.FD()); err != nil {
		log.Fatalf("Attach BPF program failed: %v", err)
	}
	return nil
}

func (h *HttpEbpf) Start() {
	// Write host IP to the filter_ip map.
	const valueIPAddr uint32 = 1
	if err := h.objs.FilterIp.Put(ipv4ToUint32(net.ParseIP(hostIP)), valueIPAddr); err != nil {
		log.Fatalf("Write filter ip map failed: %v", err)
	}

	// Create a ring buffer reader for the packets map.
	rd, err := ringbuf.NewReader(h.objs.Packets)
	if err != nil {
		log.Fatalf("opening ringbuf reader: %s", err)
	}
	defer rd.Close()

	// Close the reader when upload, which will exit the read loop.
	go func() {
		<-h.stopper

		if err := rd.Close(); err != nil {
			log.Fatalf("closing ringbuf reader: %s", err)
		}
	}()

	// httpPacket is generated by bpf2go.
	var packet httpPacket
	for {
		record, err := rd.Read()
		if err != nil {
			if errors.Is(err, ringbuf.ErrClosed) {
				log.Println("Exiting..")
				return
			}
			log.Printf("reading from reader: %s", err)
			continue
		}

		// Parse the ringbuf event entry into a httpPacket structure.
		if err := binary.Read(bytes.NewBuffer(record.RawSample), binary.LittleEndian, &packet); err != nil {
			log.Printf("parsing ringbuf event: %s", err)
			continue
		}

		// Decode httpPacket to traffic metric
		if traffic, err := DecodeMapItem(&packet); err != nil {
			log.Printf("DecodeMapItem error: %v", err)
		} else {
			h.ch <- *traffic
		}
	}
}

func (h *HttpEbpf) Unload(err error) {
	h.stopper <- struct{}{}
	if err = syscall.SetsockoptInt(h.rawSock, syscall.SOL_SOCKET, SO_DETACH_BPF, h.objs.SocketFilterHttp.FD()); err != nil {
		log.Fatalf("Detach BPF program failed: %v", err)
	}
}

// OpenRawSock opens a raw socket and binds it to the specified network interface.
func OpenRawSock(netIfName string) (int, error) {
	// ETH_P_IP: Internet Protocol version 4 (IPv4)
	// ETH_P_ARP: Address Resolution Protocol (ARP)
	// ETH_P_IPV6: Internet Protocol version 6 (IPv6)
	// ETH_P_RARP: Reverse ARP
	// ETH_P_LOOP: Loopback protocol
	const ETH_P_ALL uint16 = 0x03

	// Create a raw socket that listens to all protocols.
	sock, err := syscall.Socket(syscall.AF_PACKET,
		syscall.SOCK_RAW|syscall.SOCK_NONBLOCK|syscall.SOCK_CLOEXEC, int(Htons(ETH_P_ALL)))
	if err != nil {
		return 0, err
	}

	sll := syscall.SockaddrLinklayer{}
	sll.Protocol = Htons(ETH_P_ALL)

	netIf, err := net.InterfaceByName(netIfName)
	if err != nil {
		return 0, err
	}
	sll.Ifindex = netIf.Index

	// Bind the socket to the specified network interface.
	if err := syscall.Bind(sock, &sll); err != nil {
		return 0, err
	}
	return sock, nil
}

// DecodeMapItem decode httpPacket form ringbuf to traffic metric
func DecodeMapItem(packet *httpPacket) (*Traffic, error) {
	traffic := new(Traffic)
	traffic.Type = packet.Type
	traffic.DstIP = intToIP(packet.DstIp).String()
	traffic.DstPort = packet.DstPort
	traffic.SrcIP = intToIP(packet.SrcIp).String()
	traffic.SrcPort = packet.SrcPort
	traffic.Duration = packet.Duration
	traffic.Method = MethodToString(packet.Method)
	traffic.URL = string(packet.Url[:])
	traffic.Code = string(packet.Status[:])
	if pod, ok := global.Ip2Pod.GetPodByIP(intToIP(packet.SrcIp)); ok {
		traffic.Flow = 2
		traffic.PodName = pod.Name
		traffic.NodeName = pod.Spec.NodeName
		traffic.NameSpace = pod.Namespace
	} else if pod, ok := global.Ip2Pod.GetPodByIP(intToIP(packet.DstIp)); ok {
		traffic.Flow = 1
		traffic.PodName = pod.Name
		traffic.NodeName = pod.Spec.NodeName
		traffic.NameSpace = pod.Namespace
	} else {
		return nil, fmt.Errorf("can't find pod by ip %s", intToIP(packet.SrcIp).String())
	}
	return traffic, nil
}

func MethodToString(method uint32) string {
	switch method {
	case 1:
		return "GET"
	case 2:
		return "POST"
	case 3:
		return "PUT"
	case 4:
		return "DELETE"
	case 5:
		return "HEAD"
	case 6:
		return "PATCH"
	}
	return ""
}

// ipv4ToUint32 converts net.IP to IPv4 number
func ipv4ToUint32(ip net.IP) uint32 {
	return uint32(ip[0])<<24 | uint32(ip[1])<<16 | uint32(ip[2])<<8 | uint32(ip[3])
}

// intToIP converts IPv4 number to net.IP
func intToIP(ipNum uint32) net.IP {
	ip := make(net.IP, 4)
	binary.BigEndian.PutUint32(ip, ipNum)
	return ip
}

// Htons converts to network byte order short uint16.
func Htons(i uint16) uint16 {
	b := make([]byte, 2)
	binary.BigEndian.PutUint16(b, i)
	return *(*uint16)(unsafe.Pointer(&b[0]))
}

// Htonl converts to network byte order long uint32.
func Htonl(i uint32) uint32 {
	b := make([]byte, 4)
	binary.BigEndian.PutUint32(b, i)
	return *(*uint32)(unsafe.Pointer(&b[0]))
}

// Ntohs converts to host byte order short uint16.
func Ntohs(i uint16) uint16 {
	b := make([]byte, 2)
	binary.BigEndian.PutUint16(b, i)
	return *(*uint16)(unsafe.Pointer(&b[0]))
}

// Ntohs converts to host byte order short uint32.
func Ntohl(i uint32) uint32 {
	b := make([]byte, 4)
	binary.BigEndian.PutUint32(b, i)
	return *(*uint32)(unsafe.Pointer(&b[0]))
}
