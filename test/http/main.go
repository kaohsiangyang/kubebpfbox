package main

//go:generate go run github.com/cilium/ebpf/cmd/bpf2go -type packet --target=amd64 http ../../ebpf/http/http.c
import (
	"bytes"
	"encoding/binary"
	"errors"
	"fmt"
	"log"
	"net"
	"os"
	"os/signal"
	"syscall"
	"unsafe"

	"github.com/cilium/ebpf"
	"github.com/cilium/ebpf/ringbuf"
	"github.com/cilium/ebpf/rlimit"
)

const (
	SO_ATTACH_BPF = 0x32                     // 50
	SO_DETACH_BPF = syscall.SO_DETACH_FILTER // 27
	ProtocolICMP  = 1                        // Internet Control Message
)

func main() {
	stopper := make(chan os.Signal, 1)
	signal.Notify(stopper, os.Interrupt, syscall.SIGTERM)

	if err := rlimit.RemoveMemlock(); err != nil {
		log.Fatalf("Removing memlock: %v", err)
	}

	objs := httpObjects{}
	if err := loadHttpObjects(&objs, nil); err != nil {
		if err != nil {
			var verr *ebpf.VerifierError
			if errors.As(err, &verr) {
				fmt.Printf("%+v\n", verr)
			}
		}
		log.Fatalf("loading objects: %v", err)
	}
	defer objs.Close()

	netIfName := "eth0"

	rawSock, err := OpenRawSock(netIfName)
	if err != nil {
		log.Fatalf("Open raw sock failed: %v", err)
	}

	if err := syscall.SetsockoptInt(rawSock, syscall.SOL_SOCKET, SO_ATTACH_BPF, objs.SocketFilterHttp.FD()); err != nil {
		log.Fatalf("Attach BPF program failed: %v", err)
	}
	// defer syscall.SetsockoptInt(sock, syscall.SOL_SOCKET, SO_DETACH_BPF, prog.FD())
	// log.Printf("=======ip, %v\n", e.IPaddress)
	// log.Printf("=====FFFF==ip, %v\n", uint64(Htonl(IP4toDec(e.IPaddress))))
	const valueIPAddr uint32 = 1
	if err := objs.FilterIp.Put(ipv4ToUint32(net.ParseIP("192.168.122.180")), valueIPAddr); err != nil {
		log.Fatalf("Write filter ip map failed: %v", err)
	}

	rd, err := ringbuf.NewReader(objs.Packets)
	if err != nil {
		log.Fatalf("opening ringbuf reader: %s", err)
	}
	defer rd.Close()

	// Close the reader when the process receives a signal, which will exit
	// the read loop.
	go func() {
		<-stopper

		if err := rd.Close(); err != nil {
			log.Fatalf("closing ringbuf reader: %s", err)
		}
	}()

	log.Println("Waiting for events..")

	log.Printf("%-4s %-15s %-7s -> %-15s %-7s %-5s %-5s %-6s\n",
		"Type",
		"SrcIp",
		"SrcPort",
		"DstIp",
		"DstPort",
		"ReqSz",
		"RspSz",
		"Status",
	)

	// bpfEvent is generated by bpf2go.
	var packet httpPacket
	for {
		record, err := rd.Read()
		if err != nil {
			if errors.Is(err, ringbuf.ErrClosed) {
				log.Println("Received signal, exiting..")
				return
			}
			log.Printf("reading from reader: %s", err)
			continue
		}

		// Parse the ringbuf event entry into a bpfEvent structure.
		if err := binary.Read(bytes.NewBuffer(record.RawSample), binary.LittleEndian, &packet); err != nil {
			log.Printf("parsing ringbuf event: %s", err)
			continue
		}

		log.Printf("%-4d %-15s %-7d -> %-15s %-7d %-5d %-5d %-6s\n",
			packet.Type,
			intToIP(packet.SrcIp),
			Ntohs(packet.SrcPort),
			intToIP(packet.DstIp),
			Ntohs(packet.DstPort),
			packet.ReqPayloadSize,
			packet.RspPayloadSize,
			packet.Status,
		)
	}
}

func OpenRawSock(netIf string) (int, error) {
	// ETH_P_IP: Internet Protocol version 4 (IPv4)
	// ETH_P_ARP: Address Resolution Protocol (ARP)
	// ETH_P_IPV6: Internet Protocol version 6 (IPv6)
	// ETH_P_RARP: Reverse ARP
	// ETH_P_LOOP: Loopback protocol
	const ETH_P_ALL uint16 = 0x03

	sock, err := syscall.Socket(syscall.AF_PACKET,
		syscall.SOCK_RAW|syscall.SOCK_NONBLOCK|syscall.SOCK_CLOEXEC, int(Htons(ETH_P_ALL)))
	if err != nil {
		return 0, err
	}
	sll := syscall.SockaddrLinklayer{}
	sll.Protocol = Htons(ETH_P_ALL)

	netIfp, _ := net.InterfaceByName(netIf)
	sll.Ifindex = netIfp.Index
	if err := syscall.Bind(sock, &sll); err != nil {
		return 0, err
	}
	return sock, nil
}

// Htons converts to network byte order short uint16.
func Htons(i uint16) uint16 {
	b := make([]byte, 2)
	binary.BigEndian.PutUint16(b, i)
	return *(*uint16)(unsafe.Pointer(&b[0]))
}

// Htonl converts to network byte order long uint32.
func Htonl(i uint32) uint32 {
	b := make([]byte, 4)
	binary.BigEndian.PutUint32(b, i)
	return *(*uint32)(unsafe.Pointer(&b[0]))
}

func ipv4ToUint32(ip net.IP) uint32 {
	return uint32(ip[0])<<24 | uint32(ip[1])<<16 | uint32(ip[2])<<8 | uint32(ip[3])
}

// intToIP converts IPv4 number to net.IP
func intToIP(ipNum uint32) net.IP {
	ip := make(net.IP, 4)
	binary.BigEndian.PutUint32(ip, ipNum)
	return ip
}

// Ntohs converts to host byte order short uint16.
func Ntohs(i uint16) uint16 {
	b := make([]byte, 2)
	binary.BigEndian.PutUint16(b, i)
	return *(*uint16)(unsafe.Pointer(&b[0]))
}

// Ntohs converts to host byte order short uint32.
func Ntohl(i uint32) uint32 {
	b := make([]byte, 4)
	binary.BigEndian.PutUint32(b, i)
	return *(*uint32)(unsafe.Pointer(&b[0]))
}
